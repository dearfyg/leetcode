# LeetCode每日一题
## 前缀树
### 208
### 词频统计
### 出现最多
# 多路io复用

#### 阻塞

> ​	首先要使客户端和服务器交互，那么肯定要经过以下步骤，
>
> 1. 打开一个socket
> 2. 绑定端口
> 3. 监听端口
> 4. 建立链接
> 5. 接受客户端数据
> 6. 数据处理
> 7. 关闭链接

在以上步骤中，建立链接需要经过三次握手，会产生阻塞，还有就是接受客户端数据，如果客户端没有发送数据那么他会一直阻塞下去。

#### 非阻塞

我们肯定不会让服务端一直阻塞着，不处理其他客户端的请求，所以我们想到了，可以开多个线程去处理，每一个建立链接和接收数据都可以开一个线程去处理。但是这样是属于我们用户侧的'小聪明'，我们需要让kernel给我们处理，所以kernel给了我们一个新的read函数（此函数在没有接受到客户端传来的数据立马返回-1）多了一个文件描述符，

#### 简单的多路io复用

但是我们的线程终究是有限的(32位的linux系统中，一个线程差不多8m，假如一个是4g内存，抛弃内核的1g。就是3g/8m)

我们又想到了一个方法，我们每次派出一个线程来把read的文件描述符放到一个数组中，然后派另外一个线程去循环这个数组，这样就用一个线程解决了。

但是每次循环数据，有-1时候还是浪费了一次系统调用。

我们需要内核去遍历。所以我们又需要请求kernel给我们提供一个方法。

#### select

这就是kernel给提供的一个新的方法，`select`

其实和上面的是一样的，我们这此是把read的文件描述符放到一个list中，然后一个线程去调用select将这个列表传进去，由内核进行遍历，遍历后将文件描述符做上标识，然后我们再去循环select返回的list。

但是这样我们也发现了他也有弊端。

1. 需要复制list到内核中，数据多的话资源浪费
2. 内核循环完我们还需要循环
3. 依旧是同步的处理，只是减少了系统调用切换上下文的开销。

#### poll

只是去除了select监听1024个文件描述符的限制

#### epoll

这里就是我们的大boss了。

解决了select的3个弊端。
